// use futures::channel::mpsc;
// use futures::future::BoxFuture;
// use futures::future::FutureExt;
// use futures::lock::Mutex;
// use futures::sink::SinkExt;
// use futures::stream::Stream;
// use hash_ring::HashRing;
// use paxakos::append::AppendError;
// use paxakos::communicator::Acceptance;
// use paxakos::communicator::AcceptanceFor;
// use paxakos::communicator::Committed;
// use paxakos::communicator::Communicator;
// use paxakos::communicator::Vote;
// use paxakos::communicator::VoteFor;
// use paxakos::error::ShutDown;
// use paxakos::invocation::NayOf;
// use paxakos::invocation::YeaOf;
// use paxakos::invocation::{AbstainOf, CoordNumOf, LogEntryOf, NodeIdOf, NodeOf, RoundNumOf};
// use paxakos::retry::RetryPolicy;
// use paxakos::*;
// use rand::Rng;
// use serde::{Deserialize, Serialize};
// use std::collections::HashMap;
// use std::collections::HashSet;
// use std::convert::Infallible;
// use std::sync::atomic::AtomicUsize;
// use std::sync::Arc;
// use std::time::Duration;
// use thiserror::Error;

// use anyhow::Result;
// use paxakos::{LogEntry, State};
// use uuid::Uuid;

// use crate::hash_ring::HashRingNode;

// mod hash_ring;
// mod util;

// fn main() -> Result<()> {
//     let num_nodes = 3;
//     // let node_a = PrototypingNode::new();
//     // let node_b = PrototypingNode::new();
//     // let node_c = PrototypingNode::new();

//     let nodes = (0..num_nodes)
//         .map(|_| PrototypingNode::new())
//         .collect::<Vec<_>>();

//     //vec![node_a.clone(), node_b.clone(), node_c.clone()];

//     let communicators = DirectCommunicators::new();

//     let spawned = nodes
//         .iter()
//         .map(|node| spawn_node(node.clone(), nodes.clone(), communicators.clone()))
//         .collect::<Vec<_>>();

//     // let node_a = spawn_node(node_a, nodes.clone(), communicators.clone());
//     // let node_b = spawn_node(node_b, nodes.clone(), communicators.clone());
//     // let node_c = spawn_node(node_c, nodes, communicators);

//     let num = Arc::new(AtomicUsize::new(1));
//     let appends = spawned.into_iter().map(|node| {
//         let num = Arc::clone(&num);
//         std::thread::spawn(|| {
//             futures::executor::block_on(async move {
//                 //num += 1;
//                 let num = num.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
//                 node.append(
//                     add_node(format!("{}.{}.{}.{}", num, num, num, num)),
//                     RetryIndefinitely::without_pausing(),
//                 )
//                 .await
//                 .unwrap();
//                 // let _ = node_a
//                 //     .append(
//                 //         add_node("1.1.1.1".to_string()),
//                 //         RetryIndefinitely::without_pausing(),
//                 //     )
//                 //     .await;
//             })
//         })
//     });

//     // futures::executor::block_on(async move {
//     //     let mut num = 0;
//     //     for node in spawned {
//     //         num += 1;
//     //         node.append(
//     //             add_node(format!("{}.{}.{}.{}", num, num, num, num)),
//     //             RetryIndefinitely::without_pausing(),
//     //         )
//     //         .await
//     //         .unwrap();
//     //     }
//     //     // let _ = node_a
//     //     //     .append(
//     //     //         add_node("1.1.1.1".to_string()),
//     //     //         RetryIndefinitely::without_pausing(),
//     //     //     )
//     //     //     .await;
//     // });

//     // Because Bob and Charlie reply without synchronization, either may reply
//     // first. However, all participants will observe the same person replying
//     // first.
//     // let b = std::thread::spawn(|| {
//     //     futures::executor::block_on(async move {
//     //         let _ = node_b
//     //             .append(
//     //                 add_node("2.2.2.2".to_string()),
//     //                 RetryIndefinitely::without_pausing(),
//     //             )
//     //             .await;
//     //     });
//     // });
//     // let c = std::thread::spawn(|| {
//     //     futures::executor::block_on(async move {
//     //         let _ = node_c
//     //             .append(
//     //                 add_node("3.3.3.3".to_string()),
//     //                 RetryIndefinitely::without_pausing(),
//     //             )
//     //             .await;
//     //     });
//     // });

//     let mut num = 0;
//     // Let's wait for the appends to go through.
//     for node in appends {
//         node.join().unwrap();
//         num = num + 1;
//         println!("num joined: {}", num);
//     }
//     // b.join().unwrap();
//     // c.join().unwrap();

//     // It is guaranteed that all messages above have been appended to the shared log
//     // at this point. However, one node may not know about it yet and the others may
//     // not have gotten a chance to apply it to their state. Let's give them a chance
//     // to do that.
//     std::thread::sleep(std::time::Duration::from_millis(100));

//     // Graceful shutdown is possible (see `Node::shut_down`) but is too involved for
//     // this example.
//     std::process::exit(0);

//     Ok(())
// }

// fn add_node(ip_address: String) -> HashRingOperation {
//     HashRingOperation::AddNode(AddNodeOperation {
//         id: Uuid::new_v4(),
//         ip_address,
//     })
// }

// #[derive(Clone, Debug, Deserialize, Serialize)]
// pub enum HashRingOperation {
//     AddNode(AddNodeOperation),
// }

// impl LogEntry for HashRingOperation {
//     type Id = Uuid;

//     fn id(&self) -> Self::Id {
//         match self {
//             HashRingOperation::AddNode(op) => op.id(),
//         }
//     }
// }

// #[derive(Clone, Debug, Deserialize, Serialize)]
// pub struct AddNodeOperation {
//     id: Uuid,
//     ip_address: String,
// }

// impl LogEntry for AddNodeOperation {
//     type Id = Uuid;

//     fn id(&self) -> Self::Id {
//         self.id
//     }
// }

// // #[derive(Clone, Debug, Deserialize, Serialize)]
// // pub struct HashRing {
// //     ring: HashMap<u64, String>, // Hash to IP mapping
// // }
// // impl HashRing {
// //     fn new() -> HashRing {
// //         HashRing {
// //             ring: HashMap::new(),
// //         }
// //     }
// //     fn from_hash_map(ring: HashMap<u64, String>) -> HashRing {
// //         HashRing { ring }
// //     }
// // }

// #[derive(Clone, Debug)]
// pub struct HashRingState {
//     node_id: usize,
//     nodes: Vec<PrototypingNode>,
//     node_ip_addresses: Vec<String>,
//     applied: HashSet<Uuid>,
//     hash_ring: HashRing,
// }

// impl HashRingState {
//     pub fn new(node_id: usize, nodes: Vec<PrototypingNode>) -> Self {
//         Self {
//             node_id,
//             nodes,
//             node_ip_addresses: Vec::new(),
//             applied: HashSet::new(),
//             hash_ring: HashRing::new(),
//         }
//     }
// }

// impl State for HashRingState {
//     type Frozen = Self;

//     type Context = ();

//     type LogEntry = HashRingOperation;
//     type Outcome = HashRing;
//     type Effect = ();
//     type Error = Infallible;

//     type Node = PrototypingNode;

//     fn apply(
//         &mut self,
//         log_entry: &Self::LogEntry,
//         _context: &mut Self::Context,
//     ) -> Result<(Self::Outcome, Self::Effect), Self::Error> {
//         let own_node_id = format!("{:X}", self.node_id + 10);

//         if self.applied.insert(log_entry.id()) {
//             match log_entry {
//                 HashRingOperation::AddNode(operation) => {
//                     self.node_ip_addresses.push(operation.ip_address.clone());
//                     let nodes = self
//                         .node_ip_addresses
//                         .clone()
//                         .into_iter()
//                         .map(|ip_address| HashRingNode::from_ip_address(ip_address))
//                         .collect();
//                     let hash_ring = HashRing::from_nodes(nodes, 100);
//                     println!("[{}]: {:?} {:?}", own_node_id, log_entry, self.applied);
//                     // hash_ring.to_image().save("hash_ring.png").unwrap();
//                     return Ok((hash_ring, ()));
//                 }
//             }
//         }

//         Ok((self.hash_ring.clone(), ()))
//     }

//     fn cluster_at(&self, _round_offset: std::num::NonZeroUsize) -> Vec<Self::Node> {
//         println!("cluster_at {}", self.node_id);
//         self.nodes.clone()
//     }

//     fn freeze(&self, _context: &mut Self::Context) -> Self::Frozen {
//         self.clone()
//     }

//     fn concurrency(_: Option<&Self>) -> Option<std::num::NonZeroUsize> {
//         // Forbid multiple rounds to be settled concurrently.
//         // Block on each round until it is settled.
//         Some(std::num::NonZeroUsize::new(1).unwrap())
//     }
// }

// static NODE_ID_DISPENSER: std::sync::atomic::AtomicUsize = std::sync::atomic::AtomicUsize::new(0);

// #[derive(Debug, Clone)]
// pub struct PrototypingNode(usize);

// impl PrototypingNode {
//     pub fn new() -> Self {
//         Self(NODE_ID_DISPENSER.fetch_add(1, std::sync::atomic::Ordering::Relaxed))
//     }

//     pub fn with_id(id: usize) -> Self {
//         Self(id)
//     }
// }

// impl NodeInfo for PrototypingNode {
//     type Id = usize;

//     fn id(&self) -> Self::Id {
//         self.0
//     }
// }

// pub struct HashRingInvocation;

// impl Invocation for HashRingInvocation {
//     type RoundNum = u32;
//     type CoordNum = u32;

//     type State = HashRingState;

//     type Yea = ();
//     type Nay = Infallible;
//     type Abstain = Infallible;

//     type Ejection = Infallible;

//     type CommunicationError = DirectCommunicatorError;
// }

// #[derive(Debug, Error)]
// pub enum DirectCommunicatorError {
//     #[error("other")]
//     Other,

//     #[error("timeout")]
//     Timeout,
// }

// type RequestHandlers<I> = HashMap<NodeIdOf<I>, RequestHandler<I>>;
// type EventListeners<I> = Vec<mpsc::Sender<DirectCommunicatorEvent<I>>>;

// #[derive(Debug)]
// pub struct DirectCommunicators<I: Invocation> {
//     #[allow(clippy::type_complexity)]
//     request_handlers: Arc<Mutex<RequestHandlers<I>>>,
//     event_listeners: Arc<Mutex<EventListeners<I>>>,
// }

// impl<I: Invocation> DirectCommunicators<I> {
//     pub fn new() -> Self {
//         Self {
//             request_handlers: Arc::new(Mutex::new(HashMap::new())),
//             event_listeners: Arc::new(Mutex::new(Vec::new())),
//         }
//     }

//     pub async fn register(&self, node_id: NodeIdOf<I>, handler: RequestHandler<I>) {
//         let mut handlers = self.request_handlers.lock().await;
//         handlers.insert(node_id, handler);
//     }

//     pub fn events(&self) -> impl Stream<Item = DirectCommunicatorEvent<I>> {
//         let (send, recv) = mpsc::channel(16);

//         futures::executor::block_on(async {
//             let mut listeners = self.event_listeners.lock().await;
//             listeners.push(send);
//         });

//         recv
//     }

//     pub fn create_communicator_for(&self, node_id: NodeIdOf<I>) -> DirectCommunicator<I> {
//         DirectCommunicator {
//             set: self.clone(),
//             node_id,
//         }
//     }
// }

// impl<I: Invocation> Clone for DirectCommunicators<I> {
//     fn clone(&self) -> Self {
//         Self {
//             request_handlers: Arc::clone(&self.request_handlers),
//             event_listeners: Arc::clone(&self.event_listeners),
//         }
//     }
// }

// impl<I: Invocation> Default for DirectCommunicators<I> {
//     fn default() -> Self {
//         Self::new()
//     }
// }

// #[derive(Clone, Debug)]
// pub struct DirectCommunicatorEvent<I: Invocation> {
//     pub sender: NodeIdOf<I>,
//     pub receiver: NodeIdOf<I>,
//     pub payload: DirectCommunicatorPayload<I>,
// }

// #[derive(Clone, Debug)]
// pub enum DirectCommunicatorPayload<I: Invocation> {
//     Prepare {
//         round_num: RoundNumOf<I>,
//         coord_num: CoordNumOf<I>,
//     },
//     Promise(bool),
//     Propose {
//         round_num: RoundNumOf<I>,
//         coord_num: CoordNumOf<I>,
//         log_entry: Arc<LogEntryOf<I>>,
//     },
//     Accept(bool),
//     Commit {
//         round_num: RoundNumOf<I>,
//         coord_num: CoordNumOf<I>,
//         log_entry: Arc<LogEntryOf<I>>,
//     },
//     CommitById {
//         round_num: RoundNumOf<I>,
//         coord_num: CoordNumOf<I>,
//     },
//     Committed(bool),
// }

// #[derive(Debug)]
// pub struct DirectCommunicator<I: Invocation> {
//     set: DirectCommunicators<I>,
//     node_id: NodeIdOf<I>,
// }

// impl<I: Invocation> Clone for DirectCommunicator<I> {
//     fn clone(&self) -> Self {
//         Self {
//             set: self.set.clone(),
//             node_id: self.node_id,
//         }
//     }
// }

// macro_rules! send_fn {
//     (
//         $self:ident, $receivers:ident $(, $non_copy_arg:ident)* ;
//         $method:ident $(, $arg:ident)* ;
//         $request_payload:expr;
//         $response_payload:expr;
//     ) => {{
//         $receivers
//             .iter()
//             .map(move |receiver| {
//                 let this = $self.clone();
//                 let receiver_id = receiver.id();
//                 let delay = Duration::from_millis(rand::thread_rng().gen_range(50..100));

//                 $( send_fn!(@ $non_copy_arg); )*

//                 (
//                     receiver,
//                     async move {
//                         {
//                             let listeners = this.set.event_listeners.lock().await;
//                             for mut l in listeners.iter().cloned() {
//                                 let _ = l.send(DirectCommunicatorEvent {
//                                     sender: this.node_id,
//                                     receiver: receiver_id,
//                                     payload: $request_payload,
//                                 }).await;
//                             }
//                         }

//                         sleep(delay).await;

//                         let result = {
//                             let handlers = this.set.request_handlers.lock().await;
//                             let handler = match handlers.get(&receiver_id) {
//                                 Some(handler) => handler,
//                                 None => return Err(DirectCommunicatorError::Other),
//                             };

//                             handler.$method($($arg),*)
//                         }
//                         .await;
//                         let response = result
//                             .try_into()
//                             .map_err(|_| DirectCommunicatorError::Other);

//                         {
//                             let listeners = this.set.event_listeners.lock().await;
//                             for mut l in listeners.iter().cloned() {
//                                 let _ = l.send(DirectCommunicatorEvent {
//                                     sender: receiver_id,
//                                     receiver: this.node_id,
//                                     payload: $response_payload(&response),
//                                 }).await;
//                             }
//                         }

//                         sleep(delay).await;

//                         response
//                     }
//                     .boxed(),
//                 )
//             })
//             .collect()
//     }};

//     (@ $non_copy_arg:ident) => {
//         let $non_copy_arg = $non_copy_arg.clone();
//     }
// }

// impl<I: Invocation + 'static> Communicator for DirectCommunicator<I> {
//     type Node = NodeOf<I>;

//     type RoundNum = RoundNumOf<I>;
//     type CoordNum = CoordNumOf<I>;

//     type LogEntry = LogEntryOf<I>;

//     type Error = DirectCommunicatorError;

//     type SendPrepare = BoxFuture<'static, Result<VoteFor<Self>, Self::Error>>;
//     type Abstain = AbstainOf<I>;

//     type SendProposal = BoxFuture<'static, Result<AcceptanceFor<Self>, Self::Error>>;
//     type Yea = YeaOf<I>;
//     type Nay = NayOf<I>;

//     type SendCommit = BoxFuture<'static, Result<Committed, Self::Error>>;
//     type SendCommitById = BoxFuture<'static, Result<Committed, Self::Error>>;

//     fn send_prepare<'a>(
//         &mut self,
//         receivers: &'a [Self::Node],
//         round_num: Self::RoundNum,
//         coord_num: Self::CoordNum,
//     ) -> Vec<(&'a Self::Node, Self::SendPrepare)> {
//         send_fn!(
//             self, receivers;
//             handle_prepare, round_num, coord_num;
//             DirectCommunicatorPayload::Prepare { round_num, coord_num };
//             |r| DirectCommunicatorPayload::Promise(matches!(r, &Ok(Vote::Given(_))));
//         )
//     }

//     fn send_proposal<'a>(
//         &mut self,
//         receivers: &'a [Self::Node],
//         round_num: Self::RoundNum,
//         coord_num: Self::CoordNum,
//         log_entry: Arc<Self::LogEntry>,
//     ) -> Vec<(&'a Self::Node, Self::SendProposal)> {
//         send_fn!(
//             self, receivers, log_entry;
//             handle_proposal, round_num, coord_num, log_entry;
//             DirectCommunicatorPayload::Propose { round_num, coord_num, log_entry: log_entry.clone() };
//             |r| DirectCommunicatorPayload::Accept(matches!(r, &Ok(Acceptance::Given(_))));
//         )
//     }

//     fn send_commit<'a>(
//         &mut self,
//         receivers: &'a [Self::Node],
//         round_num: Self::RoundNum,
//         coord_num: Self::CoordNum,
//         log_entry: Arc<Self::LogEntry>,
//     ) -> Vec<(&'a Self::Node, Self::SendCommit)> {
//         send_fn!(
//             self, receivers, log_entry;
//             handle_commit, round_num, coord_num, log_entry;
//             DirectCommunicatorPayload::Commit { round_num, coord_num, log_entry: log_entry.clone() };
//             |r| DirectCommunicatorPayload::Committed(matches!(r, &Ok(_)));
//         )
//     }

//     fn send_commit_by_id<'a>(
//         &mut self,
//         receivers: &'a [Self::Node],
//         round_num: Self::RoundNum,
//         coord_num: Self::CoordNum,
//         log_entry_id: <Self::LogEntry as LogEntry>::Id,
//     ) -> Vec<(&'a Self::Node, Self::SendCommitById)> {
//         send_fn!(
//             self, receivers;
//             handle_commit_by_id, round_num, coord_num, log_entry_id;
//             DirectCommunicatorPayload::CommitById { round_num, coord_num };
//             |r| DirectCommunicatorPayload::Committed(matches!(r, &Ok(_)));
//         )
//     }
// }

// fn roll_for_failure(rate: f32) -> bool {
//     use rand::Rng;

//     rand::thread_rng().gen::<f32>() < rate
// }

// fn spawn_node(
//     node_info: PrototypingNode,
//     all_nodes: Vec<PrototypingNode>,
//     communicators: DirectCommunicators<HashRingInvocation>,
// ) -> NodeHandle<HashRingInvocation> {
//     let (send, recv) = futures::channel::oneshot::channel();

//     std::thread::spawn(move || {
//         let (handler, mut node) = futures::executor::block_on(
//             HashRingInvocation::node_builder()
//                 .for_node(node_info.id())
//                 .communicating_via(communicators.create_communicator_for(node_info.id()))
//                 .with_initial_state(HashRingState::new(node_info.id(), all_nodes))
//                 .spawn(),
//         )
//         .unwrap();

//         send.send(node.handle()).unwrap();

//         futures::executor::block_on(communicators.register(node_info.id(), handler));

//         futures::executor::block_on(futures::future::poll_fn(|cx| {
//             let _ = node.poll_events(cx);

//             std::task::Poll::<()>::Pending
//         }));
//     });

//     futures::executor::block_on(recv).unwrap()
// }

// #[derive(Debug)]
// pub struct RetryIndefinitely<I>(u64, PhantomSend<I>);

// impl<I> RetryIndefinitely<I> {
//     pub fn without_pausing() -> Self {
//         Self(0, PhantomSend::new())
//     }

//     pub fn pausing_up_to(duration: std::time::Duration) -> Self {
//         Self(duration.as_millis() as u64, PhantomSend::new())
//     }
// }

// impl<I: Invocation> RetryPolicy for RetryIndefinitely<I> {
//     type Invocation = I;
//     type Error = Infallible;
//     type StaticError = ShutDown;
//     type Future = BoxFuture<'static, Result<(), Self::Error>>;

//     fn eval(&mut self, _err: AppendError<Self::Invocation>) -> Self::Future {
//         let limit = self.0;

//         async move {
//             if limit > 0 {
//                 use rand::Rng;

//                 let delay = rand::thread_rng().gen_range(0..=limit);
//                 let delay = std::time::Duration::from_millis(delay);

//                 sleep(delay).await;
//             }

//             Ok(())
//         }
//         .boxed()
//     }
// }

// async fn sleep(duration: std::time::Duration) {
//     if duration > std::time::Duration::ZERO {
//         futures_timer::Delay::new(duration).await;
//     }
// }

// #[derive(Copy, Debug)]
// pub struct PhantomSend<T>(std::marker::PhantomData<T>);

// unsafe impl<T> Send for PhantomSend<T> {}

// impl<T> PhantomSend<T> {
//     pub fn new() -> Self {
//         Self(std::marker::PhantomData)
//     }
// }

// impl<T> Default for PhantomSend<T> {
//     fn default() -> Self {
//         Self(Default::default())
//     }
// }

// impl<T> Clone for PhantomSend<T> {
//     fn clone(&self) -> Self {
//         Self(self.0)
//     }
// }
