use crossbeam::channel::{bounded, Receiver, RecvTimeoutError, Sender};
use rand::{thread_rng, Rng};
use std::collections::{HashMap, HashSet};
use std::thread;
use std::time::{Duration, Instant};

#[derive(PartialEq)]
enum Role {
    Follower,
    Candidate,
    Leader,
}

type NodeId = u32;
type TermId = u32;

struct Node {
    role: Role,
    term: TermId,
    voted_for: Option<NodeId>,
    votes_received: HashSet<NodeId>,
    nodes: HashSet<NodeId>,
    id: NodeId,
    //last_heartbeat: Instant,
    next_timeout: Instant,
    next_heartbeat: Instant,
    sender: Sender<Message>,
    receiver: Receiver<Message>,
    // started_leadership: Option<Instant>,
    //died_at: Option<Instant>,
    will_revive_at: Option<Instant>,
    will_die_at: Option<Instant>,
}

impl Node {
    fn new(
        id: u32,
        nodes: HashSet<u32>,
        sender: Sender<Message>,
        receiver: Receiver<Message>,
    ) -> Self {
        let mut node = Node {
            role: Role::Follower,
            term: 0,
            voted_for: None,
            votes_received: HashSet::new(),
            nodes,
            id,
            next_timeout: Instant::now(),
            next_heartbeat: Instant::now(),
            sender,
            receiver,
            will_die_at: None,
            will_revive_at: Some(Instant::now()),
        };
        node.set_next_timeout();
        node
    }

    fn set_next_timeout(&mut self) {
        self.next_timeout = Instant::now()
            + Duration::from_millis(
                thread_rng().gen_range(5000..self.nodes.len() as u64 * 100 + 5000),
            );
    }

    fn set_next_heartbeat(&mut self) {
        self.next_heartbeat = Instant::now() + Duration::from_millis(1000);
    }

    fn poll(&mut self) {
        if let Some(will_revive_at) = self.will_revive_at {
            if Instant::now() > will_revive_at {
                // Revive now, plan when to next die
                self.will_revive_at = None;
                self.will_die_at =
                    Some(Instant::now() + Duration::from_millis(thread_rng().gen_range(0..60_000)));
                //println!("[{}]-{}: revived", self.id, self.term);
            } else {
                return;
            }
        }

        if let Some(will_die_at) = self.will_die_at {
            if Instant::now() > will_die_at {
                self.will_die_at = None;
                self.will_revive_at =
                    Some(Instant::now() + Duration::from_millis(thread_rng().gen_range(0..10_000)));
                //println!("[{}]-{}: died", self.id, self.term);
                return;
            }
        }

        if Instant::now() > self.next_heartbeat && self.role == Role::Leader {
            self.send_heartbeat();
        }

        if Instant::now() > self.next_timeout && self.role != Role::Leader {
            self.on_timeout();
        }

        match self.receiver.recv_timeout(Duration::from_millis(10)) {
            Ok(message) => self.receive_message(message),
            Err(_) => (),
        }
    }

    fn send_heartbeat(&mut self) {
        println!(
            "[{}]-{}: sending heartbeat, dieing in {}",
            self.id,
            self.term,
            (self.will_die_at.unwrap() - Instant::now()).as_millis()
        );

        for &node_id in &self.nodes {
            if node_id != self.id {
                self.sender
                    .send(Message::Heartbeat(HeartbeatMessage {
                        term: self.term,
                        sender: self.id,
                        receiver: node_id,
                    }))
                    .unwrap();
            }
        }

        self.set_next_heartbeat();
    }

    fn on_timeout(&mut self) {
        println!("[{}]-{}: heartbeat timed out", self.id, self.term);

        match self.role {
            Role::Follower | Role::Candidate => {
                self.role = Role::Candidate;
                self.term += 1;
                self.voted_for = Some(self.id);
                self.votes_received.clear();
                self.votes_received.insert(self.id);
                self.set_next_timeout();

                println!("[{}]-{}: proposed self as candidate", self.id, self.term);

                for &node_id in &self.nodes {
                    if node_id != self.id {
                        self.sender
                            .send(Message::RequestVote(RequestVoteMessage {
                                term: self.term,
                                requester: self.id,
                                requestee: node_id,
                            }))
                            .unwrap();
                    }
                }
            }
            _ => {}
        }
    }

    fn reset_term_as_follower(&mut self, term: TermId) {
        self.term = term;
        self.voted_for = None;
        self.role = Role::Follower;
        self.voted_for = None;
        self.votes_received.clear();
        self.set_next_timeout();
    }

    fn vote_for(&mut self, votee: NodeId) {
        if self.voted_for.is_some() {
            panic!("Tried to vote twice");
        }
        println!("[{}]-{}: voting for {}", self.id, self.term, votee);
        self.voted_for = Some(votee);
        self.sender
            .send(Message::Vote(VoteMessage {
                term: self.term,
                voter: self.id,
                votee,
            }))
            .unwrap();

        self.set_next_timeout();
    }

    fn receive_message(&mut self, message: Message) {
        thread::sleep(Duration::from_millis(thread_rng().gen_range(50..300)));
        match message {
            Message::Vote(message) => self.receive_vote_message(message),
            Message::Heartbeat(message) => self.receive_heartbeat_message(message),
            Message::RequestVote(message) => self.receive_request_vote_message(message),
        }
    }

    fn receive_vote_message(&mut self, message: VoteMessage) {
        if message.term < self.term {
            println!(
                "[{}]-{}: ignoring note from previous term from {}",
                self.id, self.term, message.voter
            );
            return;
        }

        if message.term > self.term {
            println!(
                "[{}]-{}: received later term {} vote from {}, resetting as follower",
                self.id, self.term, message.term, message.voter
            );
            self.reset_term_as_follower(message.term);
            return;
        }

        if let Role::Candidate = self.role {
            self.votes_received.insert(message.voter);
            println!(
                "[{}]-{}: vote received from {}",
                self.id, self.term, message.voter
            );
            if self.votes_received.len() > self.nodes.len() / 2 {
                println!("[{}]-{}: ascending to leadership", self.id, self.term);
                self.role = Role::Leader;
                self.send_heartbeat();
            }
        }
    }

    fn receive_heartbeat_message(&mut self, message: HeartbeatMessage) {
        if message.term < self.term {
            return;
        }

        if message.term > self.term {
            println!(
                "[{}]-{}: received later term {} heartbeat from {}, resetting as follower",
                self.id, self.term, message.term, message.sender
            );
            self.reset_term_as_follower(message.term);
        }

        self.set_next_timeout();
    }

    fn receive_request_vote_message(&mut self, message: RequestVoteMessage) {
        if message.term < self.term {
            println!(
                "[{}]-{}: ignoring note from previous term from {}",
                self.id, self.term, message.requester
            );
            return;
        }

        if message.term > self.term {
            println!(
                "[{}]-{}: received later term {} request vote from {}, resetting as follower",
                self.id, self.term, message.term, message.requester
            );
            self.reset_term_as_follower(message.term);
            self.vote_for(message.requester);
            return;
        }

        match self.voted_for {
            None => self.vote_for(message.requester),
            Some(voted) if voted == message.requester => self.vote_for(message.requester),
            _ => {}
        }
    }
}

enum Message {
    Vote(VoteMessage),
    Heartbeat(HeartbeatMessage),
    RequestVote(RequestVoteMessage),
}

struct VoteMessage {
    term: TermId,
    voter: NodeId,
    votee: NodeId,
}

struct HeartbeatMessage {
    term: TermId,
    sender: NodeId,
    receiver: NodeId,
}

struct RequestVoteMessage {
    term: TermId,
    requester: NodeId,
    requestee: NodeId,
}

struct NodeChannel {
    sender: Sender<Message>,
    receiver: Receiver<Message>,
}

fn main() {
    let num_nodes = 10;

    let nodes: HashSet<NodeId> = (0..num_nodes).into_iter().collect();

    let mut node_channels = HashMap::new();

    let (node_sender, hub_receiver) = bounded(1000);

    for &node_id in &nodes {
        let (hub_sender, node_receiver) = bounded(1000);

        node_channels.insert(
            node_id,
            NodeChannel {
                sender: hub_sender,
                receiver: hub_receiver.clone(),
            },
        );

        let nodes = nodes.clone();
        let node_sender = node_sender.clone();
        thread::spawn(move || {
            let mut node = Node::new(node_id, nodes.clone(), node_sender, node_receiver);
            loop {
                node.poll();
            }
        });
    }

    let receive_message = |node_id: NodeId,
                           node_channels: &HashMap<NodeId, NodeChannel>|
     -> Result<(), RecvTimeoutError> {
        match node_channels
            .get(&node_id)
            .unwrap()
            .receiver
            .recv_timeout(Duration::from_millis(10))
        {
            Ok(message) => forward_message(message, &node_channels),
            Err(err) => match err {
                RecvTimeoutError::Timeout => {}
                RecvTimeoutError::Disconnected => return Err(err),
            },
        };
        Ok(())
    };

    fn forward_message(message: Message, node_channels: &HashMap<NodeId, NodeChannel>) {
        match message {
            Message::Vote(ref vote) => node_channels.get(&vote.votee).unwrap().sender.send(message),
            Message::Heartbeat(ref heartbeat) => node_channels
                .get(&heartbeat.receiver)
                .unwrap()
                .sender
                .send(message),
            Message::RequestVote(ref request) => node_channels
                .get(&request.requestee)
                .unwrap()
                .sender
                .send(message),
        }
        .unwrap();
    }

    loop {
        for &node_id in &nodes {
            receive_message(node_id, &node_channels).unwrap();
        }
    }
}
